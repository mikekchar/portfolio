---
layout: default
title: Three Rings of Programming
permalink: ThreeRings
description: The three main aspects of programming which affect process
category: Agile
summary: In this post I discuss the three main aspects of programming that I feel affect process the most.  These aspects are described as a set of 3 concentric circles with the center circle being the most basic and the outer circle being most advanced.
---
## What Aspects of Programming Affect Process?

There are many activities that are undertaken in the creation of software.
All of these activities are important, but programming is the core
activity that is required.  Without programming, there is no product.
(Note: Some may argue that activities which attract money and direct
it into the pockets of programmers so that they continue to program
is more important.  I am in no position to disagree...)

In a somewhat unconscious tribute to "[The Book of the 5 Rings](http://archive.org/details/MiyamotoMusashi-BookOfFiveRingsgoRinNoSho)", I have
separated the aspects of programming that I think have the most
influence on process into three concentric circles.  At the center
is the first circle.  This is the most basic aspect and must be
successful before the other two aspects can be successful.
Similarly, the second circle is more advanced and difficult.
It must be successful before the third aspect can be successful.
Finally, the third circle is the most difficult.

The circles arguably decrease in importance as they go out.
The first circle is the most important while the third circle
is the least.  However, opportunity is ordered in the opposite
direction.  The third circle represents the most opportunity,
while the first circle represents the least.  As a sustaining
operation, this must be carefully considered.  A lack of
attention to the latter circles reduces the opportunity to
continue developing to nearly zero.

### The first circle: Solving problems

The essence of computer programming is the encoding of a solution
to a problem in a series of instructions that a computer can
understand and follow. If you do this, you are programming a computer.
It is the most basic and important part of programming.  There
are three stages of solving a problem:

1. Identifying the problem:  If the problem is poorly understood
    or incorrecly identified, the job can not be completed.

2. Encoding the solution:  If the computer does not have code that
can be executed, the problem isn't solved.

3. Verifying the solution: If the encoded solution does not solve
the problem, then the job is not finished.

This first circle is the absolute minimum that must be done in order
to say that a programming job is complete.  Beginning programmers
often feel this is all that must be done and spend all of their attention
in this circle.  Because all of the business value of a job appears
to lie in this circle, management often mistakenly encourages
programmers not to stray from this circle.

### The second circle: Communicating to humans

Almost every problem that is being solved by computers today is easy
to solve.  There are exceptions, of course, which contain complex
math or naturally mind bending logic.  Even with these exceptions,
the vast majority of code complexity lies in the expression
of the code, not in the solution of the problem.
In other words, as we solve more and more problems with our code,
the complexity of navigating the code quickly outstrips the
complexity of solving the problems.

In the second circle, we are not only interested in the correct
solution of the problem.  It is not enough to make the computer
understand what the code is doing.  We must also make sure that
the next programmer understands it quickly and easily too.  There
are three ways to achieve this, which I have ordered by increasing
value (and, unfortunately, difficulty of production):

1. Separate Documentation: Usually written by programmers or
analysts, these documents are designed to help other programmers
navigate and understand key points of the code/design.

2. Integrated Documentation. Written by programmers, these are
usually comments or Javadoc style notations. This also includes
documents automatically generated from the code like those
produced by Doxygen.

3. Implied Documentation.  This is not documentation in the true
sense, but rather self documenting code.  Careful design coupled
with intelligent naming can lead to code that requires little or
no separate documentation to understand.  So-called unit tests,
or behavioral tests can also be used for this kind of documentation.

Most programmers can see the value of communication, either
through documentation, or through executable code.  The problem
often lies in the programmer's desire or ability to create
such communication.  Often the effort needed to communicate is
thrown up against the pressure to deliver quickly and loses out.
Many programmers are also deluded about their own ability to
communicate through self documenting code.  Management can
usually be persuaded that there is customer value in achieving
high throughput through the use of clear or documented code.
However, they often underestimate the value and defer such
production in favor of short term goals.

### The third circle: Simplification

There is a limit to the effectiveness of communication.  No matter
how well we communicate our intent there comes a point at which
the sheer size of the material overwhelms our ability to comprehend
it.  In the third circle we are interested in creating the least
complex code that still solves the problem.

There are three main ways to keep code simple:

1. Controlling scope: I discuss this to some degree in my post on
"[Focused Development](../FocusedDevelopment)" (subtitled, 
"Saving lots of money", for a good reason). Unnecessary requirements
can actually add orders of magnitude to the complexity of the code.

2. Partitioning: Why is it more helpful to program on a system with
an OS than one without?  Surely the increase in complexity that
the OS brings should increase the complexity of the solution's code.
Of course, the opposite is true: it simplifies it.  That's because
the OS is highly partitioned from the solution's code.  Partitioning
can happen at any level. Controlling data scope, encapsulation,
controlling side effects, controlling coupling, and the creation of
libraries are all examples of partitioning.

3. Elegance:  Some solutions are simplier than others.  It takes skill
and experience to discover the simplest approach.  Sometimes as requirements
in the system solidify simpler approaches present themselves.

While I expect that this will be controversial with some, I believe that
simplicity can not usually be designed in up front.  Programming is
an active processes.  A program whose requirements will never change
is a program that is no longer being developed - a dead project.

As I said previously the solution of problems is the base of all programming.
As long as there are new problems to solve, there is both a risk of 
increasing complexity and also an opportunity for simplification.  Projects
which do not engage in refactoring have essentially abandoned simplicity.

Simplification is the most advanced and difficult of the three circles,
but it also offers the most potential for return on investment.
Quite frequently programmers do not value simplicity, feeling that
all solutions which produce the correct answer are equally valuable.
A lack of experience can also lead programmers to overlook simple
solutions.  Conversely, very advanced programmers may sometimes
create very elegant and simple solutions which their comrades
fail to understand.  In a sense, the advanced programmer does not
keep their audience in mind and fails in the second circle.

From the point of view of management, it is often quite difficult
to justify activity which does not directly provide customer value.
Scope is particularly difficult to control because unneeded features
are often seen as valuable to sales people (the "box list" can
actually seem more important to sales than the set of features that
users actually want).  Partitioning and the pursuit of elegance is
seen as "gold plating", or "polishing a round ball", especially when
it is done in the form of refactoring.


