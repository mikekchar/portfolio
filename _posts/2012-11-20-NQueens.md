---
layout: default
title: Puzzle - 8 Queens
permalink: NQueens
category: Puzzles
description: Put 8 queens safely on a chess board.
summary: A famous puzzle.  Put 8 queens on a chess board such than none can attack another.  I've chosen a backtracking algorithm using bitfields to solve the problem. 
---
## One solution to a very famous puzzle

For my second puzzle, I decided to choose a very famous one.  It's called
the [8 Queens](http://en.wikipedia.org/wiki/Eight_queens_puzzle) puzzle.
If you don't want to read the excellent Wikipedia article, the
puzzle is to put 8 queens on a chess board in such a way that none
can attack each other.  As you probably know, a chess board is a grid of
8x8 squares.  A queen can attack horizontally across a row, veritically
across a column or diagonally.

For me, this is an interesting problem since it is easy to encode the board
into an array of integers.  In other words, imagine that a row is encoded
as an integer of 8 bits, where the bit is set if a queen is present.  The
entire board can be represented by an array of 8 of these integers.  Our goal
is to turn on a single bit in each row, while ensuring that only a single
bit is set in each column.  Furthermore, we need to make sure that no
there are no bits are set on a diagonal.

### The solution

I've chosen to use a backtracking algorithm.  Basically, the method
accepts an array of rows (integers) and a size.  The size indicates
how large a board we are using (this solution will work for any board
size that doesn't overload our integers).

It first looks at the existing rows and determines which columns
are empty.  It then iterates over the empty columns, trying to add
a row such that there are no diagonal attacks possible.  If it finds one,
it adds the row and trys to continue solving the puzzle from there.
If it exhausts all the empty columns, it pops the top row and returns to
iterating over the empty columns in the previous row.  The puzzle is solved
if we end up with a board of the correct size.  For several board sizes,
there is no possible solution.  In that case the algorithm simply drops
out with an empty set of rows.

Here is the code for the main recursive loop:

    def solve(rows, size):
        """Solve a board of a given size with these current rows."""
        if len(rows) == size:
            # End of the recursion.  We have a solution.
            return True

        # Iterate over the columns which don't already have a queen.
        candidates = findCandidates(rows, size)
        for c in candidates:
            if not hasDiagonals(rows, c):
                # If this column can't be attacked on the diagonals,
                # Add the column and try to solve the puzzle from here
                rows.append(c)
                if solve(rows, size):
                    # We have a solution
                    return True

        # If we have iterated over all the available columns, pop
        # this row and continue iterating on the columns in the previous row
        if rows != []:
            del(rows[-1])

        return False

Of course, this solution depends on two helper functions: findCandidates()
and hasDiagonals().  findCandidates simply takes the array of rows 
along with the size of the board.  Basically, we want to find a list of
possible places we can place the queen.  Since queens can attack horizontally,
we can only have one queen in a new row. Similarly, they can attack
vertically, so we can only have one queen in a column.  We need to find
out which columns are free to put a queen in.  This method returns a list
of candidate rows; a list of rows where each one has a queen added to
an empty column.

It's quite easy to find the empty columns.  We simply need to take the
previous rows and bitwise OR them together.  This gives us an integer with
a bit set where there is a queen already.  We can then test each bit to
find out if there is a queen there or not.  If not, we can add a row
with that bit set to our candidate rows.  Here's the code:

    def findCandidates(rows, size):
        """Return a list of the candidate rows where you could place a queen."""
        retVal = []

        # c is a mask indicating all the columns where queens reside.
        c = 0
        for r in rows:
            c = c | r

        # Now iterate over the columns and make a list of the ones
        # where no queens reside.
        mask = 1
        col = 0
        while col < size:
            if (c & mask) == 0:
                # If no rows have a queen here, store a candidate row
                # with the column filled (this is the same as the mask
                # we used to test with).
                retVal.append(mask)
            col += 1
            mask = mask << 1
        return retVal

Finally, we just need to detect the diagonals.  hasDiagonals() accepts
the array of rows along with a candidate new row.  It returns true if
the new row can be attacked diagonally. This is also quite easy to do.
Every row (including the candidate row) contains a single queen.  We
simply have to iterate through the rows (starting at the last one and
finishing a the first one) shifting the candidate row one bit to the
left and right each time.  If the shifted candidate row equals the
existing row, there is a diagonal attack.  Here is the code:

    def hasDiagonals(rows, row):
        """Returns true if a candidate row can be attacked diagonally."""
        retVal = False;
        left = right = row

        # We are checking from the last row up to the beginning
        for r in reversed(rows):
            # Shift once to the left and once to the right and check to
            # see if there is already a queen there.
            left = left << 1
            right = right >> 1
            retVal = (left == r) or (right == r)
            if retVal:
                break
        return retVal

I hope you found my solution interesting.  This is quite a good problem
because there are many different ways to solve it.  I will probably revisit
it again in the future.

